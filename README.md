# uropsilus
Linux based protocol for tunneling TCP traffic over ICMP. Here's a [video demo](https://www.youtube.com/watch?v=YHh-hFt5wLU) explaining how to try it out yourself; to just see the program in action skip to the 18 minute mark.


# broad overview
Uropsilus is a protocol built on top of ICMP that allows TCP messages to be tunneled via ICMP echo requests and replies (the same service used by the `ping` network utility). To run it, you need a computer to act as client (for instance, your laptop connected to a public Wifi network), and a remote computer with a trusted internet connection to act as proxy. Unfortunately, at present both hosts must be running Linux and you must have root access on both. Uropsilus also offers client-proxy encryption, but at present the protocol uses symmetric encryption, so the two hosts must have agreed on a private key beforehand.

On the client side, the protocol works by intercepting outgoing TCP traffic on the computer's network interface and redirecting it to the local loopback interface, where it can be picked up by the tunnel program. The tunnel program then crafts an ICMP echo request whose payload contains (a) a Uropsilus protocol header (detailed below), and (b) a copy of the TCP packet itself, including its IP header, all encrypted with the given private key. It then sends this ICMP echo request to the proxy, and awaits an echo reply. Upon receiving the reply, it strips off the ICMP header, parses the Uropsilus header information, and finally decrypts the TCP payload and returns it on the loopback interface, where it can be picked up by the client's relevant web browser or other application. At no point is there any visible TCP traffic to or from the client, and to the client's network gateway all of the client's traffic just looks like hundreds of ping requests and replies.

On the remote side, the proxy waits for connection requests from clients, and upon receiving one allocates the memory and prepares the relevant data structures for the new client. It then listens for ICMP echo requests from its clients, and upon receiving one strips off the ICMP header, parses the Uropsilus header information, decrypts the TCP payload, and sends it off to the server it was originally destined for. It has to modify the TCP packet in a few ways, first changing its source address from the client's address to its own, so that it will be the one to receive the TCP responses from the server. Also, because the proxy needs to be able to handle multiple clients, it has to have a way of identifying which client the server's TCP response is destined for, so Uropsilus implements a simple form of Network Address Port Translation (NAPT), changing the source port of the TCP payload and recording a port translation table that allows it link certain port numbers with their corresponding clients. Upon receiving a TCP response from a server, it checks the NAPT table (discarding the packet if a corresponding port entry is not found), changes the packet's destination port and destination IP address to those of the corresponding client in the table, encrypts the entire packet and wraps it up in ICMP and Uropsilus headers, stores it in a transmission queue ring buffer, and finally sends it as an echo reply to the client upon its next receipt of an echo request.


# why and when to use
In general, Uropsilus is applicable anytime you do not trust the network you're connected to. The first and most obvious benefit of the tunneling protocol is that it encrypts your TCP messages, making it impossible for malicious eavesdroppers to sniff data from your packets. However, there are plenty of alternative ways of doing this (VPNs or IPsec, for instance), and given that most application layer protocols today like SSH and HTTPS encrypt your data this is less of a concern.

The more valuable context for Uropsilus is when a malicious firewall or third-party is attempting to block you from accessing the internet (or from accessing certain websites in particular). Blocking or restricting TCP traffic is trivial for malicious parties to do, and the possibilies range from simply dropping or filtering TCP packets if they have control of your network gateway to more inventive options like TCP reset attacks if they don't. (This latter exploits a characteristic of TCP that allows a "reset" flag to be set in a packet, which tells its recipient to immediately cease and erase its connection with the host in question. Malicious actors can sniff attempts to make TCP connections and send back spoofed reset packets in response, blocking the client from establishing the connection. The Great Firewall of China is known to use this technique extensively.)

Uropsilus allows one to bypass many of these obstacles. Even in cases where a network gateway is blocking some or all TCP traffic, the vast majority of firewalls do not block ICMP traffic, as it is often crucial for a gateway's functioning (for instance, ICMP is used to trace out important routing information about how best to deliver packets), and so the ICMP traffic will be able to get through where the TCP traffic cannot. In addition, because the TCP payload and its IP header are encrypted by the Uropsilus protocol, a malicious actor will be unable to determine which websites or other servers a victim client is accessing, adding an additional layer of privacy for the client and preventing selective filtering.


# technical details and challenges
There were a number of possible obstructions to consider in designing the Uropsilus protocol, almost all to do with various ways in which standard gateways regulate ICMP echo traffic. By far the largest of these is the maximum size that many firewalls impose on ping payloads. In my first attempt at writing this program, I did not realize there was any such restriction, and was confused by that fact that the client did seem to be receiving many of the packets sent to it by the proxy. Eventually I realized that, although the [RFC](https://tools.ietf.org/html/rfc792) defining the ICMP echo protocol does not give any restrictions on permissible payload size, evidently a number of routers do. (Presumably this is to prevent "ping of death" and "teardrop" type attacks, both of which rely on poor handling of oversized or otherwise fragmented ping packets.) Experimenting around with the `ping -s` option, I realized that the Android hotspot with which I access the internet drops ICMP echo messages with payloads of greater than ~950 bytes, and hence fetching websites whose content could comprise tens of thousands of bytes was not be possible in the initial naive protocol implementation. (To use Uropsilus yourself you'd need to experiment and find the correct maximum payload size on your own computer.)

To work around this I implemented a fragmentation protocol inspired by IP fragmentation; when an oversized packet is encountered, it is fragmented into small pieces, each of which is sent individually (along with information about its offset relative to the start of the TCP segment, so that the recipient can put the fragments back together in the right order). This bypasses the obstruction in question, but unfortunately does drastically reduce the bandwidth of the connection provided by Uropsilus; when a 10,000 byte packet has to be sent in 10 separate increments, it slows things down significantly. However, the workaround does work.

Another issue is that most gateway firewalls drop any ICMP echo replies not requested by a host on their LAN. They do this using a 16 bit field of the ICMP header called the ID field, which allows for matching up between echo requests and echo replies. Gateways keep a table of the IDs of the echo requests sent out through it, and drop any ICMP echo replies without an ID in the table. In addition, they often have a fairly strict timeout for each ID, so often if the gateway has not received a response within ~10 seconds of sending a request it will then erase that ID's entry in the table.

This means that lopsided TCP traffic where the client is reciving more packets than it is sending (say, particularly large responses to HTTP requests) would backlog heavily in a naive protocol implementation. The solution to this is to essentially have the Uropsilus client flood the proxy with ICMP echo requests (even when it has no TCP traffic to send out), so that the proxy will always have fresh IDs to draw on in its communication. The default setting I've given for this is to send an ICMP packet every 100 milliseconds, but if you are running the program yourself you can experiment via the corresponding command line option and see what works best for you.

**To-do:** add an explanation of the information in the Uropsilus header


# future directions
First and foremost, there is a *lot* of refactoring that needs to be done; the current version is a very rough first draft of the program and much of the code is extremely sloppy. It is also quite inefficient in the way it approaches memory allocation, which compounds the already slow browsing speed imposed by the maximum ping payload size discussed above. In particular, at present the proxy server calls `malloc` and `free` for every single packet it transmits. This is probably the largest bottleneck in program speed and could be vastly improved with the use of a single memory pool.

Currently Uropsilus also does not offer any substantial encryption; at present it just uses a XOR cipher as a proof of concept. An important next step is to implement a proper encryption protocol, probably AES. As a longer term aim it would be nice if the proxy and client did not have to agree on a key beforehand, so I may try to implement a key exchange protocol.

Relatedly, there are some security issues that I need to address; for instance, currently Uropsilus offers no protection against spoofing attacks, so I hope to eventually incorporate digital signatures as well. The program is also currently vulnerable to "teardrop"-style heap overflows caused by sending a fragmented packet with an incorrect fragment offset attached; this is straightforward to fix but I haven't yet gotten around to it.

And finally, Uropsilus is written only for Linux, so another obvious direction is to write a port that allows it to run on OS X; this should not be too difficult as I rely on only a few Linux-specific features. Writing a port for Windows would be more challenging, as Windows offers much less in the way of raw sockets, but I may try to approach that as well.
